
#include <ir/ir.h>
#include <target/util.h>

#define SOA "scoreboard objectives add "
#define SPG "scoreboard players get "
#define SPS "scoreboard players set "
#define SPA "scoreboard players add "
#define SPR "scoreboard players remove "
#define SPO "scoreboard players operation "
#define DMS "data modify storage elvm:elvm "
#define DGS "data get storage elvm:elvm "
#define DRS "data remove storage elvm:elvm "

#define MEM_PHI 27146105

static const char* MCFUNCTION_REG_NAMES[7] = { "elvm_a", "elvm_b", "elvm_c", "elvm_d", "elvm_bp", "elvm_sp", "elvm_pc" };

static bool used_mem_table_store = 0;
static bool used_mem_table_load = 0;
static bool used_chr_function = 0;
static bool used_flush_function = 0;

static void mcf_char_to_string(char c, char* out) {
  if ((c >= 0 && c < 32) || c == 127)
    c = ' ';

  if (c == '"' || c == '\\') {
    out[0] = '\\';
    out[1] = c;
    out[2] = '\0';
  } else if (!(c & 0x80)) {
    out[0] = c;
    out[1] = '\0';
  } else {
    out[0] = (char)0xc0 | (char)(((unsigned)c & 0xff) >> 6);
    out[1] = (char)0x80 | (c & (char)0x3f);
    out[2] = '\0';
  }
}

static void mcf_emit_function_header(const char *name) {
  emit_line("========= %s.mcfunction =========", name);
  emit_line("# Generated by ELVM");
}

static void mcf_emit_set_reg(const char *reg, Value *value) {
  if (value->type == REG)
    emit_line(SPO "ELVM %s = ELVM %s", reg, reg_names[value->reg]);
  else if (value->type == IMM)
    emit_line(SPS "ELVM %s %d", reg, value->imm);
  else
    error("invalid value");
}

static void mcf_emit_mem_table_store(Value *addr, Value *value) {
  used_mem_table_store = 1;
  mcf_emit_set_reg("elvm_mem_val", value);
  mcf_emit_set_reg("elvm_mem_addr", addr);
  if (addr->type == REG) {
    mcf_emit_set_reg("elvm_mem_idx", addr);
    emit_line(SPO "ELVM elvm_mem_idx *= ELVM elvm_mem_phi");
    emit_line(SPO "ELVM elvm_mem_idx %%= ELVM elvm_mem_len");
  } else {
    emit_line(SPS "ELVM elvm_mem_idx %d", (addr->imm * MEM_PHI) & 31);
  }
  emit_line(DMS "mem_tmp set value []");
  emit_line("function elvm:storemem");
}

static void mcf_emit_mem_table_load(Value* addr) {
  used_mem_table_load = 1;
  mcf_emit_set_reg("elvm_mem_addr", addr);
  if (addr->type == REG) {
    mcf_emit_set_reg("elvm_mem_idx", addr);
    emit_line(SPO "ELVM elvm_mem_idx *= ELVM elvm_mem_phi");
    emit_line(SPO "ELVM elvm_mem_idx %%= elvm_mem_len");
  } else {
    emit_line(SPS "ELVM elvm_mem_idx %d", (addr->imm * MEM_PHI) & 31);
  }
  emit_line(DMS "mem_tmp set value []");
  emit_line("function elvm:loadmem");
}

static void define_mem_func(const char* name, const char* shift_func, const char* safebin_func) {
  mcf_emit_function_header(format("elvm:%s", name));
  emit_line("execute if score ELVM elvm_mem_idx matches 0 run " DMS "bin_tmp set value []");
  emit_line("execute if score ELVM elvm_mem_idx matches 0 run function elvm:%s", safebin_func);
  emit_line("execute unless score ELVM elvm_mem_idx matches 0 run function elvm:%s", shift_func);
}

static void define_shiftmem_func(const char* name, const char* mem_func) {
  mcf_emit_function_header(format("elvm:%s", name));
  emit_line(DMS "mem_tmp append from storage elvm:elvm mem[0]");
  emit_line(DRS "mem[0]");
  emit_line(SPR "elvm_mem_idx 1");
  emit_line("function elvm:%s", mem_func);
  emit_line(DMS "mem prepend from storage elvm:elvm mem_tmp[-1]");
}

static void define_safebin_func(const char* name, const char* bin_func, const char* notfound_operation) {
  mcf_emit_function_header(format("elvm:%s", name));
  emit_line("execute if data storage elvm:elvm mem[0][0] run function elvm:%s", bin_func);
  emit_line("execute unless data storage elvm:elvm mem[0][0] ", notfound_operation);
}

static void define_bin_func(const char* name, const char* shift_func, const char* operation) {
  mcf_emit_function_header(format("elvm:%s", name));
  emit_line("execute store result score ELVM elvm_test_addr run " DGS "mem[0][0].a");
  emit_line("execute if score ELVM elvm_mem_addr = ELVM elvm_test_addr %s", operation);
  emit_line("execute unless score ELVM elvm_mem_addr = ELVM elvm_test_addr run function elvm:%s", shift_func);
}

static void define_shiftbin_func(const char* name, const char* safebin_func) {
  mcf_emit_function_header(format("elvm:%s", name));
  emit_line(DMS "bin_tmp append from storage elvm:elvm mem[0][0]");
  emit_line(DRS "mem[0][0]");
  emit_line("function elvm:%s", safebin_func);
  emit_line(DMS "mem[0] prepend from storage elvm:elvm bin_tmp[-1]");
}

static void define_storeval_func() {
  mcf_emit_function_header("elvm:storeval");
  emit_line(DMS "mem[0] append value {}");
  emit_line("execute store result storage elvm:elvm mem[0][0].a run " SPG "ELVM elvm_mem_addr");
  emit_line("execute store result storage elvm:elvm mem[0][0].v run " SPG "ELVM elvm_mem_val");
}

static void define_chr_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  if (range == 256)
    mcf_emit_function_header("elvm:chr");
  else
    mcf_emit_function_header(format("elvm:chr_%d_%d", min, max));
  if (range == 2) {
    char ch[3];
    mcf_char_to_string((char)min, ch);
    emit_line("execute if score ELVM elvm_mem_val matches %d run " DMS "chr set value \"%s\"", min, ch);
    mcf_char_to_string((char)mid, ch);
    emit_line("execute if score ELVM elvm_mem_val matches %d run " DMS "chr set value \"%s\"", mid, ch);
  } else {
    if (mid <= 32)
      emit_line("execute if score ELVM elvm_mem_val matches %d..%d run " DMS "chr set value \" \"", min, mid-1);
    else
      emit_line("execute if score ELVM elvm_mem_val matches %d..%d run function elvm:chr_%d_%d", min, mid-1, min, mid);
    emit_line("execute if score ELVM elvm_mem_val matches %d..%d run function elvm:chr_%d_%d", mid, max-1, mid, max);
    if (mid > 32)
      define_chr_function(min, mid);
    define_chr_function(mid, max);
  }
}

char json_string[11156];

static void get_json_string(int len, char* out) {
  int i = 0;
  out[i++] = '[';
  for (int j = 0; j < len; j++) {
    const char* val = format("%s{\"storage\":\"elvm:elvm\",\"nbt\":\"stdout[%d]\"}", j == 0 ? "" : ",", j);
    for (; *val; val++)
      out[i++] = *val;
  }
  out[i++] = ']';
  out[i] = '\0';
}

static void define_flush_function_recursive(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:flush_%d_%d", min, max));
  if (min == 0 && range == 4) {
    for (int i = 1; i < 4; i++) {
      get_json_string(i, json_string);
      emit_line("execute if score ELVM elvm_mem_val matches %d run tellraw @a %s", i, json_string);
    }
  } else if (range == 2) {
    get_json_string(min, json_string);
    emit_line("execute if score ELVM elvm_mem_val matches %d run tellraw @a %s", min, json_string);
    get_json_string(mid, json_string);
    emit_line("execute if score ELVM elvm_mem_val matches %d run tellraw @a %s", mid, json_string);
  } else {
    emit_line("execute if score ELVM elvm_mem_val matches %d..%d run function elvm:flush_%d_%d", min, mid-1, min, mid);
    emit_line("execute if score ELVM elvm_mem_val matches %d..%d run function elvm:flush_%d_%d", mid, max-1, mid, max);
    define_flush_function_recursive(min, mid);
    define_flush_function_recursive(mid, max);
  }
}

static void define_flush256() {
  mcf_emit_function_header("elvm:flush256");
  emit_line(DRS "stdout[0]");
  emit_line(SPR "ELVM elvm_mem_val 1");
  emit_line("execute if score ELVM elvm_mem_val matches -256.. run elvm:flush256");
}

static void define_flush_function() {
  mcf_emit_function_header("elvm:flush");
  emit_line("execute store result score ELVM elvm_mem_val run " DGS "stdout");
  emit_line("function elvm:flush_0_256");
  emit_line("execute if score ELVM elvm_mem_val matches 256.. run " SPS "ELVM elvm_mem_val -1");
  emit_line("execute if score ELVM elvm_mem_val matches -1 run function elvm:flush256");
  emit_line("execute if score ELVM elvm_mem_val matches ..-1 run function elvm:flush");
  define_flush256();
  define_flush_function_recursive(0, 256);
}


static void mcf_emit_test(Inst* inst,
                          int num_commands_when_false, const char** cmds_when_false,
                          int num_commands_when_true, const char** cmds_when_true,
                          bool true_first) {
  bool inverted = 0;
  Op op = normalize_cond(inst->op, 0);
  if (op == JNE || op == JLT || op == JGT) {
    inverted = 1;
    op = normalize_cond(op, 1);
  }

  const char* if_ = inverted ? "unless" : "if";
  const char* unless = inverted ? "if" : "unless";
  const char* false_test;
  const char* true_test;
  if (inst->src.type == IMM) {
    const char* left_dots = op == JLE ? ".." : "";
    const char* right_dots = op == JGE ? ".." : "";
    false_test = format("execute %s score ELVM %s matches %s%d%s run ",
                        unless, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
    true_test = format("execute %s score ELVM %s matches %s%d%s run ",
                        if_, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
  } else {
    const char* op_str = op == JEQ ? "=" : op == JLE ? "<=" : ">=";
    false_test = format("execute %s score ELVM %s %s ELVM %s run ",
                        unless, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
    true_test = format("execute %s score ELVM %s %s ELVM %s run ",
                        if_, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
  }
  if (true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
  for (int i = 0; i < num_commands_when_false; i++)
    emit_line("%s%s", false_test, cmds_when_false[i]);
  if (!true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
}

bool was_jump = 1;

static void mcf_emit_inst(Inst* inst) {
  was_jump = 0;
  switch (inst->op) {
    case MOV: {
      mcf_emit_set_reg(reg_names[inst->dst.reg], &inst->src);
      break;
    }

    case ADD: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPR "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPA "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s += ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case SUB: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPA "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPR "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s -= ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case LOAD: {
      mcf_emit_mem_table_load(&inst->src);
      emit_line(SPO "ELVM %s = ELVM elvm_mem_res", reg_names[inst->dst.reg]);
      break;
    }

    case STORE: {
      mcf_emit_mem_table_store(&inst->src, &inst->dst);
      break;
    }

    case EXIT: {
      was_jump = 1;
      emit_line(SPS "ELVM elvm_pc -1");
      break;
    }

    case PUTC: {
      if (inst->src.type == IMM) {
        int val = inst->src.imm;
        if (val == '\n') {
          used_flush_function = 1;
          emit_line("function elvm:flush");
        } else {
          char ch[3];
          mcf_char_to_string((char)val, ch);
          emit_line(DMS "stdout append value \"%s\"", ch);
        }
      } else {
        used_chr_function = 1;
        used_flush_function = 1;
        mcf_emit_set_reg("elvm_mem_val", &inst->src);
        emit_line("execute if score ELVM elvm_mem_val matches 10 run function elvm:flush");
        emit_line("execute unless score ELVM elvm_mem_val matches 10 run function elvm:chr");
        emit_line("execute unless score ELVM elvm_mem_val matches 10 run " DMS "stdout append from storage elvm:elvm chr");
      }
      break;
    }

    case GETC: {
      /* TODO: implement */
      break;
    }

    case DUMP: {
      break;
    }

    case EQ:
    case NE:
    case LT:
    case LE:
    case GT:
    case GE: {
      const char* cmd_when_false = SPS "ELVM elvm_tmp 0";
      const char* cmd_when_true = SPS "ELVM elvm_tmp 1";
      mcf_emit_test(inst, 1, &cmd_when_false, 1, &cmd_when_true, 0);
      emit_line(SPO "ELVM %s = ELVM elvm_tmp", reg_names[inst->dst.reg]);
      break;
    }

    case JMP: {
      was_jump = 1;
      mcf_emit_set_reg("elvm_pc", &inst->jmp);
      if (inst->jmp.type == IMM)
        emit_line("function elvm:func_%d", inst->jmp.imm);
      break;
    }

    case JEQ:
    case JNE:
    case JLT:
    case JLE:
    case JGT:
    case JGE: {
      was_jump = 1;
      const char* cmds_when_false[2] = {SPA "ELVM elvm_pc 1", format("function elvm:func_%d", inst->pc+1)};
      if (inst->jmp.type == IMM) {
        const char* cmds_when_true[2] = {format(SPS "ELVM elvm_pc %d", inst->jmp.imm),
                                         format("function elvm:func_%d", inst->jmp.imm)};
        mcf_emit_test(inst, 2, cmds_when_false, 2, cmds_when_true, 0);
      } else {
        const char* cmd_when_true = format(SPO "ELVM elvm_pc = ELVM %s", reg_names[inst->jmp.reg]);
        mcf_emit_test(inst, 2, cmds_when_false, 1, &cmd_when_true, 1);
      }
      break;
    }

    default:
      error("oops");
  }
}


static void emit_main_function(Data* data) {

  mcf_emit_function_header("elvm:main");
  for (int i = 0; i < 7; i++) {
    emit_line(SOA "%s dummy", reg_names[i]);
    emit_line(SPS "ELVM %s 0", reg_names[i]);
  }

  emit_line(SOA "elvm_tmp dummy");

  emit_line(SOA "elvm_mem_phi dummy");
  emit_line(SPS "elvm_mem_phi %d", MEM_PHI);

  emit_line(SOA "elvm_mem_len dummy");
  emit_line(SPS "elvm_mem_len 32");
  emit_line(DMS "mem set value [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]");

  emit_line(SOA "elvm_mem_addr dummy");
  emit_line(SOA "elvm_mem_idx dummy");
  emit_line(SOA "elvm_mem_val dummy");
  emit_line(SOA "elvm_mem_res dummy");
  emit_line(SOA "elvm_test_addr dummy");

  emit_line(SOA "elvm_uint_max dummy");
  emit_line(SPS "ELVM elvm_uint_max %d", UINT_MAX + 1);

  emit_line(DMS "stdout set value []");

  for (int mp = 0; data; data = data->next, mp++) {
    if (data->v) {
      Value addr;
      addr.type = IMM;
      addr.imm = mp;
      Value val;
      val.type = IMM;
      val.imm = data->v;
      mcf_emit_mem_table_store(&addr, &val);
    }
  }

  emit_line("execute if score ELVM elvm_pc matches 0.. run function elvm:loop");
}

static void emit_loop_function(int pc_count) {
  mcf_emit_function_header("elvm:loop");
  emit_line("function elvm:func_0_%d", pc_count);
  emit_line("execute if score ELVM elvm_pc matches 0.. run function elvm:loop");
}

static void emit_pc_search_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:func_%d_%d", min, max));
  if (range < 4) {
    for (int i = 0; i < range; i++) {
      emit_line("execute if score ELVM elvm_pc matches %d run function elvm:func_%d", min + i, min + i);
    }
  } else {
    emit_line("execute if score ELVM elvm_pc matches %d..%d run function elvm:func_%d_%d", min, mid-1, min, mid);
    emit_line("execute if score ELVM elvm_pc matches %d..%d run function elvm:func_%d_%d", mid, max-1, mid, max);
    emit_pc_search_function(min, mid);
    emit_pc_search_function(mid, max);
  }
}

static void define_utility_functions() {
  if (used_mem_table_store) {
    define_mem_func("storemem", "storememsh", "safestorebin");
    define_shiftmem_func("storememsh", "storemem");
    define_safebin_func("safestorebin", "storebin", "run function elvm:storeval");
    define_bin_func("storebin", "storebinsh",
                    "store result storage elvm:elvm mem[0][0].v int 1 run " SPG "ELVM elvm_mem_val");
    define_shiftbin_func("storebinsh", "safestorebin");
    define_storeval_func();
  }

  if (used_mem_table_load) {
    define_mem_func("loadmem", "loadmemsh", "safeloadbin");
    define_shiftmem_func("loadmemsh", "loadmem");
    define_bin_func("safeloadbin", "loadbin", "run " SPS "ELVM elvm_mem_res 0");
    define_bin_func("loadbin", "loadbinsh", "store result score ELVM elvm_mem_res run " DGS "mem[0][0].v");
    define_shiftbin_func("loadbinsh", "safeloadbin");
  }

  if (used_chr_function)
    define_chr_function(0, 256);
  if (used_flush_function)
    define_flush_function();
}

void target_mcfunction(Module* module) {
  reg_names = MCFUNCTION_REG_NAMES;

  int pc = -1;
  for (Inst* inst = module->text; inst; inst = inst->next) {
    if (inst->pc != pc) {
      pc = inst->pc;
      if (!was_jump) {
        emit_line(SPA "ELVM elvm_pc 1");
        emit_line("function elvm:func_%d", inst->pc);
      }
      mcf_emit_function_header(format("elvm:func_%d", pc));
    }
    mcf_emit_inst(inst);
  }

  emit_pc_search_function(0, pc+1);
  emit_main_function(module->data);
  emit_loop_function(pc+1);
  define_utility_functions();

}
